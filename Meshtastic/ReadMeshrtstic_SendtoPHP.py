# Purpose:
# This program tracks Meshtastic nodes. It receives coordinate data sent by a Meshtastic node
# (generated by the Meshtastic app), extracts the latitude and longitude values, and then
# forwards them to a remote PHP endpoint (update.php). The server stores all received
# coordinates and displays them on a map (map.php), which automatically updates.
#
# Author: Farid Farahmand
# Date: 2025
# Environment: Python 3, PyCharm
# Received message format: 38.3476683, -122.6765367
# Output: Received message from !43b797fc: 38.3476683, -122.6765367
# Message to PHP: https://faridfarahmand.net/LeafletMap/update.php?lat=38.39&lon=-122.675&label=4321
# View the Map URL: https://faridfarahmand.net/LeafletMap/map.php
# All coordinates are saved here: https://faridfarahmand.net/LeafletMap/positions.csv
#
# Application:
# cd /Users/farid/PycharmProjects/InSee2/Meshtastic
# python3 ./ReadMeshrtstic_SendtoPHP.py
# From your Phone App on a different node, type in the coordinates and send:
#   38.3477094, -122.6764803
# Then check https://faridfarahmand.net/LeafletMap/map.php
# You can also check this file to ensure the data was received:
#   https://srv1009-files.hstgr.io/e89a8ef2e5486ff2/files/public_html/LeafletMap/positions.csv




import meshtastic
import meshtastic.serial_interface
from pubsub import pub
import requests  # <-- new


UPDATE_URL = "https://faridfarahmand.net/LeafletMap/update.php"


def _make_label_from_fromid(from_id: str) -> str:
    """
    Derive label from last 4 hex characters of fromId.
    Example: '!43b797fc' -> '97fc'
    """
    if not from_id:
        return "node"

    # Strip leading '!' if present
    clean = from_id.lstrip("!")

    # Take last 4 characters
    if len(clean) >= 4:
        return clean[-4:]
    return clean


def _try_send_coordinates(from_id: str, text: str):
    """
    Try to parse 'lat, lon' from the text string and send to update.php.
    Expected format: '38.3476683, -122.6765367'
    If parsing fails, do nothing.
    """
    try:
        parts = text.split(",")
        if len(parts) < 2:
            return  # not in lat, lon format

        lat_str = parts[0].strip()
        lon_str = parts[1].strip()

        lat = float(lat_str)
        lon = float(lon_str)

        label = _make_label_from_fromid(from_id)

        params = {
            "lat": lat,
            "lon": lon,
            "label": label,
        }

        # Fire-and-forget HTTP GET
        requests.get(UPDATE_URL, params=params, timeout=5)

    except Exception as e:
        # Keep it quiet unless debugging is needed
        # print(f"Could not send coords to server: {e}")
        pass


def on_receive_text(packet, interface=None, topic=pub.AUTO_TOPIC):
    """
    Called whenever a text message is received.
    Tries several possible locations for the text field.
    Also tries to parse coordinates and send them to update.php.
    """
    decoded = packet.get("decoded", {}) or {}

    text = None

    # 1) Preferred: decoded["text"] (set by _onTextReceive)
    if "text" in decoded:
        text = decoded["text"]

    # 2) Sometimes it may be under decoded["data"]["text"]
    if text is None:
        data = decoded.get("data", {})
        if isinstance(data, dict):
            text = data.get("text")

    # 3) Fallback: decode payload bytes
    if text is None:
        payload = (
            decoded.get("payload")
            or (decoded.get("data", {}) or {}).get("payload")
        )
        if isinstance(payload, (bytes, bytearray)):
            text = payload.decode("utf-8", errors="ignore")
        elif payload is not None:
            text = str(payload)

    # If still nothing, just show the packet for debugging
    if not text:
        print("Received packet but could not extract text:")
        print(packet)
        return

    from_id = packet.get("fromId", "unknown")

    # Print exactly as before
    print(f"Received message from {from_id}: {text}")

    # NEW: try to parse "lat, lon" and send to PHP
    _try_send_coordinates(from_id, text)


def main():
    print("Connecting to Meshtastic device...")
    interface = meshtastic.serial_interface.SerialInterface()  # auto-detect

    # Subscribe to text-only topic
    pub.subscribe(on_receive_text, "meshtastic.receive.text")

    print("Listening for incoming text messages... (Ctrl+C to exit)")
    try:
        while True:
            pass
    except KeyboardInterrupt:
        print("Exiting...")
        interface.close()


if __name__ == "__main__":
    main()
